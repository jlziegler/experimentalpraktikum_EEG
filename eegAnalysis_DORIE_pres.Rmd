---
title: "Experimentalpraktikum"
subtitle: "EEG Analyse in R"
author: "Joshua Ziegler"
date: "10.02.2021"
output: 
  revealjs::revealjs_presentation:
    self_contained: false
    reveal_plugins: ["menu"]
    transition: slide 
---
<style>
    .reveal .slides {
        text-align: left;
    }
    .reveal .slides section>* {
        margin-left: 0;
        margin-right: 0;
    }
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(eegUtils) 
library(tidyverse)
```

# Was ist R? 
*R is a free software environment for statistical computing and graphics. It compiles and runs on a wide variety of UNIX platforms, Windows and MacOS.*     
(Quelle: https://www.r-project.org)

# Warum R?
![RStudio Overview](imgs/rstudio_overview.png)

# eegUtils
- R Paket von Matt Craddock:    
<small><i>eegUtils is a **package for the processing, manipulation, and plotting of EEG data**. It includes functions for **importing data from a variety of file formats** (including Biosemi, Brain Vision Analyzer, and EEGLAB), many of the **typical steps in pre-preprocessing** (filtering, referencing, artefact rejection), more **advanced processing techniques (time-frequency analysis, ICA)**, and **several types of plot** that are common in the field (ERP plots, time-frequency plots, topographical scalp maps). Although it uses custom object classes, it is designed such that these are **always translatable to standard R data.frames**, and thus can be used with any of the myriad packages and methods that support standard R formats.</i>   
(Quelle: https://craddm.github.io/eegUtils/index.html)</small>  
 
- Github: https://github.com/craddm/eegUtils
- Hier verwendete Version: eegUtils_0.6.0 (Stand 09.02.2021)
- R version 4.0.2 (2020-06-22), RStudio Version 1.3.1073

# Studie
![Dorie](imgs/dorie.jpg)

## Natural Referent Vowel Modell (NRV, Polka & Bohn 2011): 
- Vokale werden anhand ihrer phonetischen Merkmale unterschieden
- Im Vokalraum peripher liegende Vokale sind aufgrund von Formantkonvergenz salienter
  + Diskrimination von zentral zu peripher einfacher    
![(Polka & Bohn 2011)](imgs/pb11_nrv.png){width=45%}

## Material
- Deutsche Langvokale /o:/ & /u:/ (jeweils 5 Tokens)
- 10 Versuchspersonen (rechtshändig, monolingual Deutsch, (fast) keine Dialektkompetenz, keine Hörbeeinträchtigung, keine neurologische oder psychiatrische Vorerkrankung)   
```{r, message=F, out.width="50%"}
source("formant_map.R")
```

## Methode
- Passives Oddball-Design (in beide Richtungen)
  + z.B.: o-o-o-o-o-**u**-o-o-o...
  + 800 Standards & 120 Deviants (pro Bedingung)
- EEG: 
  + 32 Elektroden 
  + 500 Hz Samplingrate
  + Random ISI (600-1100 ms)
- Berechnung der identity Mismatch Negativity (iMMN):
  + Differenz der EKP-Signale des Standards und Deviants der selben Stimuli
  + an der FCz bei 120-200 ms
  
## Hypothesen:
- Intra-Stimuli: 
  + stärkerer Effekt bei /u:/-Dev als bei /u:/-Stan 
  + schwächerer Effekt bei /o:/
- Inter-Stimuli: 
  + signifikanter Unterschied = direktionale Asymmetrie

# Auswertung in R mit *eegUtils*
## Laden der Rohdaten
<small>eegUtils-Funktion: ```import_raw```</small>
```{r, echo=T, results='hide', message=F, eval=FALSE}
# Liste der vhdr-Dateien im "raw"-Ordner
temp <- list.files(path = "./raw", pattern="*.vhdr")
# Leere Liste erstellen
DORlist <- list()
# Daten importieren
for (i in temp){
  filename <- paste0(i)     # filename from temp
  DORlist[[i]] <-           # save the following elements in a list
    assign(filename,        # assign respective filename to data
           import_raw(i,    # import data set
                      file_path = "./raw",   # path to subdirectory "raw"
                      participant_id = make.names(gsub("*.vhdr$", "", i)))  # set particpant ID
  )
  rm(list = ls(pattern = "vhdr$"))  # remove files that are not in list
}
```

## Überblick über die Rohdaten (1)
<small>eegUtils-Funktion: ```browse_data```</small>
![Datenbrowser (Shiny-App)](imgs/browse_data.png)

## Überblick über die Rohaten (2)
![Datenorganisation in Listen](imgs/list_org.png)

## Überblick über die Rohaten (3)
![Datenorganisation in Listen (2)](imgs/list_org_signals.png)

## Preprocessing
<small>eegUtils-Funktionen: ```electrode_locations, eeg_filter, eeg_reference, epoch_data```</small>
```{r, echo=T, results='hide', message=F, eval=FALSE}
# Preprocessing
DORlist <-      # overwrite list
  lapply(DORlist, function(x){     # apply the following to every element in list
# ELECTRODE LOCATIONS
   x <- electrode_locations(x,
                           overwrite = T,
                           method = "biosemi64")
# FILTER
   x <- eeg_filter(x,
                   low_freq = 0.1,
                   high_freq = 30,
                   method = "fir")
# RE-REF
   x <- eeg_reference(x, 
                      ref_chans = c("A1", "A2"))
# EPOCH
   x <- epoch_data(x, 
                   events = c("S111",
                              "S112",
                              "S212",
                              "S211",
                              "S121",
                              "S123",
                              "S223",
                              "S221"), 
                   epoch_labels = c("oeStan",    # o-e (o-Standard)
                                    "eoStan",    
                                    "oeDev",
                                    "eoDev",     # e-o (o-Deviant)
                                    "ouStan",    # o-u (o-Standard)
                                    "uoStan",    # u-o (u-Standard)
                                    "ouDev",     # o-u (u-Deviant)
                                    "uoDev"),    # u-o (o-Deviant)
                   time_lim = c(-.2, .8),
                   baseline = c(-.2, 0))
}
)
```

## ICA
<small>eegUtils-Funktion: ```run_ICA```</small>
```{r, echo=T, eval=FALSE}
# Leere ICA Liste
ICAlist <- list()
# ICA
ICAlist <- 
  lapply(DORlist, function(x){
           run_ICA(x)   # default: SOBI ICA
    }
    )
# add prefix "ICA_" to ICA data
names(ICAlist) <- paste("ICA_", names(ICAlist), sep = "")
```

## Überblick ICA
<small>eegUtils-Funktion: ```view_ica```</small>
![ICA Überblick](imgs/ICA_topo.png)

## Überblick nach ICA Komponenten
![ICA Überblick nach Komponenten](imgs/ICA_comp.png)

## Artifact Rejection
<small>eegUtils-Funktionen: ```ar_eogcor, ar_acf, ar_chanfoc, ar_trialfoc, apply_ica```</small>
```{r, echo=T, eval=FALSE}
# ICA components (using map2() from purrr package (tidyverse))
DORlist <-
  map2(DORlist, ICAlist, function(x, y){
    # print participant id
    print(x$epochs$participant_id[1])
    # ICA EOG
    print("ICA EOG")
    ICA_comp_eog <- ar_eogcor(decomp = y, 
                              data = x, 
                              HEOG = c("HEOGli", "HEOGre"), 
                              VEOG = c("VEOGo", "VEOGu"),
                              plot = F)
    # ICA MUSCLE
    print("ICA Muscle")
    ICA_comp_mus <- ar_acf(y,
                           plot = F)
    # ICA CHANNEL
    print("ICA Channel")
    ICA_comp_chn <- ar_chanfoc(y,
                               plot = F)
    # ICA TRIAL
    print("ICA Trial")
    ICA_comp_trl <- ar_trialfoc(y,
                                plot = F)
    # COMBINE COMPONENTS    
    ICA_comp_rem <- c(ICA_comp_eog, ICA_comp_mus, ICA_comp_chn, ICA_comp_trl)
    print(ICA_comp_rem)
    # REMOVE COMPONENTS
    x <- apply_ica(data = x,    
                   decomp = y, 
                   comps = ICA_comp_rem)
  })
```

```{r, eval=FALSE}
# REMOVE ICAlist
rm(ICAlist)
```

## Output der Artifact Rejection:
![AR Output andhand eines Datensatzes](imgs/ICA_out.png)

## Correlation Coefficient Plot
![Correlation Coefficient Plot](imgs/cc_plot.png)

# iMMN
## Zusammenfassen der Daten
```{r, echo=T, eval=FALSE}
# CONVERT TO DATA FRAME
DOR_df_FCz <- 
  map(DORlist, function(x){
    x %>%
      filter(epoch_labels %in% c("uoDev", "ouStan", "uoStan", "ouDev")) %>%
      as.data.frame(long = T) %>%
      filter(electrode == "FCz")
  })
# COMBINE DATASETS
DOR_gravg_FCz <- bind_rows(DOR_df_FCz)
# Tabellenkopf:
head(DOR_gravg_FCz)
```

![Tabellenkopf](imgs/head_GA.png)

## Plot Code
```{r, echo=T, eval=FALSE}
# Plot o Data
o_diff_plot <-
DOR_gravg_FCz %>%
  filter(epoch_labels %in% c("uoDev", "ouStan")) %>%
  ggplot(aes(x = time, y = amplitude)) +
    stat_summary(fun = mean, 
               geom = "line", 
               aes(colour = epoch_labels)) + 
    facet_wrap(~electrode) + # wenn mehrere elektroden
    scale_y_reverse() + 
    theme_light() +
    geom_hline(yintercept = 0) +
    geom_vline(xintercept = 0) +
    scale_x_continuous(breaks = seq(-.2, .8, .1))
```

## /o:/
![o-Plot](imgs/o_diff_plot.png){width=75%}

## /u:/
![u-Plot](imgs/u_diff_plot.png){width=75%}

## Vorbereitung für Inferenzstatistik
```{r, echo=T, eval=FALSE}
# Mittelwert für jeden Zeitpunkt, aufgeteilt nach Bedingung
diff.avg <-
  DOR_gravg_FCz %>%
  group_by(time, epoch_labels, electrode, participant_id) %>%
  summarise_at("amplitude", mean) %>%
  ungroup()

# Differenzen (Dev-Stan) bilden
# long to wide format
diff.avg <-
  diff.avg %>%
  pivot_wider(names_from = epoch_labels,
              values_from = amplitude)
  
# Zeilen substrahieren
diff.avg <-
  diff.avg %>%
  mutate(o_diff = uoDev - ouStan,
         u_diff = ouDev - uoStan,
         .keep = "unused")

# wide to long format
diff.avg <-
  diff.avg %>%
  pivot_longer(cols = c(o_diff, u_diff), 
               names_to = "epoch_diff", 
               values_to = "amplitude_diff")
# AVERAGE DATA OVER 120-200 ms
diff.avg.crit <-
  diff.avg %>%
    filter(time >= 0.12,  # 120 ms
          time <= 0.2)    # 200 ms

# mean by participant and epoch
diff.avg.crit <-
  diff.avg.crit %>% 
  group_by(electrode, participant_id, epoch_diff) %>%  # keep electrode, participant & epoch
  summarise_at("amplitude_diff", mean) %>%             # mean amplitude
  ungroup()
```

## Repeated Measures ANOVA
```{r, echo=T, eval=FALSE}
# REPEATED MEASURES ANOVA ON DIFFERENCES
print(summary(aov(amplitude_diff ~ epoch_diff + Error(participant_id), 
            data = diff.avg.crit)))
```

![ANOVA](imgs/rm_anova.png)

# Diskussion
- Intra-Stimuli:
  + Symmetrie bei /u:/
  + Asymmetrie bei /o:/ widerspricht NRV
- Inter-Stimuli: 
  + kein signifikanter Unterschied, also keine direktionale Asymmetrie
- Präliminären Daten deuten daraufhin, dass die Annahmen des NRV nicht zutreffen

# Fazit zu eegUtils
- Pros:
  + Vielzahl an Funktionen
  + Einfache Integration von *tidyverse* und *baseR*
  + Ständig in Entwicklung, Kontakt mit Entwickler über GitHub möglich
- Cons:
  + Dokumentation und Anleitung sehr knapp
  + Nicht so intuitiv wie das GUI von EEGLAB & ERPLAB
  + Nicht alle *Channel Locations* erkannt
  + Grand Average nur über Umwege möglich
  + Manuelle Korrekturen nicht vorgesehen (?)

# Quellen
<small>
- Chaumon, M., Bishop, D. V. M., & Busch, N. A. (2015). A practical guide to the selection of independent components of the electroencephalogram for artifact correction. *Journal of Neuroscience Methods*, 250, 47–63. https://doi.org/10.1016/j.jneumeth.2015.02.025   
- Craddock, M. (2021). *eegUtils: Utilities for Electroencephalographic (EEG) Analysis*. https://github.com/craddm/eegUtils, https://craddm.github.io/eegUtils.    
- Polka, L., & Bohn, O.-S. (2011). Natural Referent Vowel (NRV) framework: An emerging view of early phonetic development. *Journal of Phonetics*, 39(4), 467–478. https://doi.org/10.1016/j.wocn.2010.08.007   
- Pulvermüller, F., & Shtyrov, Y. (2006). Language outside the focus of attention: The mismatch negativity as a tool for studying higher cognitive processes. *Progress in Neurobiology*, 79(1), 49–71. https://doi.org/10.1016/j.pneurobio.2006.04.004   
- R Core Team (2020). R: A language and environment for statistical computing. *R Foundation for Statistical Computing*, Vienna, Austria. URL https://www.R-project.org/    
- Wickham et al. (2019). Welcome to the tidyverse. *Journal of Open Source Software*, 4(43), 1686, https://doi.org/10.21105/joss.01686   
</small>
